// Generated by Haxe 3.4.0 (git build development @ 75c0f05)
#include <hxcpp.h>

#ifndef INCLUDED_haxe_io_Input
#include <haxe/io/Input.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_VorbisDecodeState
#include <stb/format/vorbis/VorbisDecodeState.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_Mode
#include <stb/format/vorbis/data/Mode.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_ReaderError
#include <stb/format/vorbis/data/ReaderError.h>
#endif
#ifndef INCLUDED_stb_format_vorbis_data_ReaderErrorType
#include <stb/format/vorbis/data/ReaderErrorType.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_100d1e94ef285c83_12_new,"stb.format.vorbis.data.Mode","new",0x32de2fa8,"stb.format.vorbis.data.Mode.new","stb/format/vorbis/data/Mode.hx",12,0x6517ce48)
HX_DEFINE_STACK_FRAME(_hx_pos_100d1e94ef285c83_15_read,"stb.format.vorbis.data.Mode","read",0x52304b0e,"stb.format.vorbis.data.Mode.read","stb/format/vorbis/data/Mode.hx",15,0x6517ce48)
namespace stb{
namespace format{
namespace vorbis{
namespace data{

void Mode_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_100d1e94ef285c83_12_new)
            	HX_STACK_THIS(this)
            	}

Dynamic Mode_obj::__CreateEmpty() { return new Mode_obj; }

void *Mode_obj::_hx_vtable = 0;

Dynamic Mode_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Mode_obj > _hx_result = new Mode_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Mode_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x3ec07cd8;
}

 ::stb::format::vorbis::data::Mode Mode_obj::read( ::stb::format::vorbis::VorbisDecodeState decodeState){
            	HX_GC_STACKFRAME(&_hx_pos_100d1e94ef285c83_15_read)
            	HX_STACK_ARG(decodeState,"decodeState")
HXLINE(  16)		HX_VARI(  ::stb::format::vorbis::data::Mode,m) =  ::stb::format::vorbis::data::Mode_obj::__alloc( HX_CTX );
HXLINE(  17)		int _hx_tmp;
HXDLIN(  17)		if ((decodeState->validBits < (int)0)) {
HXLINE(  17)			_hx_tmp = (int)0;
            		}
            		else {
HXLINE(  17)			if ((decodeState->validBits < (int)1)) {
HXLINE(  17)				if ((decodeState->validBits == (int)0)) {
HXLINE(  17)					decodeState->acc = (int)0;
            				}
HXDLIN(  17)				while(true){
HXLINE(  17)					bool _hx_tmp1;
HXDLIN(  17)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  17)						if (!(decodeState->lastSeg)) {
HXLINE(  17)							_hx_tmp1 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  17)							_hx_tmp1 = true;
            						}
            					}
            					else {
HXLINE(  17)						_hx_tmp1 = false;
            					}
HXDLIN(  17)					if (_hx_tmp1) {
HXLINE(  17)						decodeState->validBits = (int)-1;
HXDLIN(  17)						goto _hx_goto_1;
            					}
            					else {
HXLINE(  17)						decodeState->bytesInSeg--;
HXDLIN(  17)						int a = decodeState->acc;
HXDLIN(  17)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  17)						int b = decodeState->input->readByte();
HXDLIN(  17)						decodeState->acc = (a + ((int)b << (int)decodeState->validBits));
HXDLIN(  17)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  17)					if (!((decodeState->validBits < (int)1))) {
HXLINE(  17)						goto _hx_goto_1;
            					}
            				}
            				_hx_goto_1:;
HXDLIN(  17)				if ((decodeState->validBits < (int)0)) {
HXLINE(  17)					_hx_tmp = (int)0;
            				}
            				else {
HXLINE(  17)					HX_VARI( int,z) = ((int)decodeState->acc & (int)(int)1);
HXDLIN(  17)					decodeState->acc = hx::UShr(decodeState->acc,(int)1);
HXDLIN(  17)					decodeState->validBits = (decodeState->validBits - (int)1);
HXDLIN(  17)					_hx_tmp = z;
            				}
            			}
            			else {
HXLINE(  17)				HX_VARI_NAME( int,z1,"z") = ((int)decodeState->acc & (int)(int)1);
HXDLIN(  17)				decodeState->acc = hx::UShr(decodeState->acc,(int)1);
HXDLIN(  17)				decodeState->validBits = (decodeState->validBits - (int)1);
HXDLIN(  17)				_hx_tmp = z1;
            			}
            		}
HXDLIN(  17)		m->blockflag = (_hx_tmp != (int)0);
HXLINE(  18)		int _hx_tmp2;
HXDLIN(  18)		if ((decodeState->validBits < (int)0)) {
HXLINE(  18)			_hx_tmp2 = (int)0;
            		}
            		else {
HXLINE(  18)			if ((decodeState->validBits < (int)16)) {
HXLINE(  18)				if ((decodeState->validBits == (int)0)) {
HXLINE(  18)					decodeState->acc = (int)0;
            				}
HXDLIN(  18)				while(true){
HXLINE(  18)					bool _hx_tmp3;
HXDLIN(  18)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  18)						if (!(decodeState->lastSeg)) {
HXLINE(  18)							_hx_tmp3 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  18)							_hx_tmp3 = true;
            						}
            					}
            					else {
HXLINE(  18)						_hx_tmp3 = false;
            					}
HXDLIN(  18)					if (_hx_tmp3) {
HXLINE(  18)						decodeState->validBits = (int)-1;
HXDLIN(  18)						goto _hx_goto_2;
            					}
            					else {
HXLINE(  18)						decodeState->bytesInSeg--;
HXDLIN(  18)						int a1 = decodeState->acc;
HXDLIN(  18)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  18)						int b1 = decodeState->input->readByte();
HXDLIN(  18)						decodeState->acc = (a1 + ((int)b1 << (int)decodeState->validBits));
HXDLIN(  18)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  18)					if (!((decodeState->validBits < (int)16))) {
HXLINE(  18)						goto _hx_goto_2;
            					}
            				}
            				_hx_goto_2:;
HXDLIN(  18)				if ((decodeState->validBits < (int)0)) {
HXLINE(  18)					_hx_tmp2 = (int)0;
            				}
            				else {
HXLINE(  18)					HX_VARI_NAME( int,z2,"z") = ((int)decodeState->acc & (int)(int)65535);
HXDLIN(  18)					decodeState->acc = hx::UShr(decodeState->acc,(int)16);
HXDLIN(  18)					decodeState->validBits = (decodeState->validBits - (int)16);
HXDLIN(  18)					_hx_tmp2 = z2;
            				}
            			}
            			else {
HXLINE(  18)				HX_VARI_NAME( int,z3,"z") = ((int)decodeState->acc & (int)(int)65535);
HXDLIN(  18)				decodeState->acc = hx::UShr(decodeState->acc,(int)16);
HXDLIN(  18)				decodeState->validBits = (decodeState->validBits - (int)16);
HXDLIN(  18)				_hx_tmp2 = z3;
            			}
            		}
HXDLIN(  18)		m->windowtype = _hx_tmp2;
HXLINE(  19)		int _hx_tmp4;
HXDLIN(  19)		if ((decodeState->validBits < (int)0)) {
HXLINE(  19)			_hx_tmp4 = (int)0;
            		}
            		else {
HXLINE(  19)			if ((decodeState->validBits < (int)16)) {
HXLINE(  19)				if ((decodeState->validBits == (int)0)) {
HXLINE(  19)					decodeState->acc = (int)0;
            				}
HXDLIN(  19)				while(true){
HXLINE(  19)					bool _hx_tmp5;
HXDLIN(  19)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  19)						if (!(decodeState->lastSeg)) {
HXLINE(  19)							_hx_tmp5 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  19)							_hx_tmp5 = true;
            						}
            					}
            					else {
HXLINE(  19)						_hx_tmp5 = false;
            					}
HXDLIN(  19)					if (_hx_tmp5) {
HXLINE(  19)						decodeState->validBits = (int)-1;
HXDLIN(  19)						goto _hx_goto_3;
            					}
            					else {
HXLINE(  19)						decodeState->bytesInSeg--;
HXDLIN(  19)						int a2 = decodeState->acc;
HXDLIN(  19)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  19)						int b2 = decodeState->input->readByte();
HXDLIN(  19)						decodeState->acc = (a2 + ((int)b2 << (int)decodeState->validBits));
HXDLIN(  19)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  19)					if (!((decodeState->validBits < (int)16))) {
HXLINE(  19)						goto _hx_goto_3;
            					}
            				}
            				_hx_goto_3:;
HXDLIN(  19)				if ((decodeState->validBits < (int)0)) {
HXLINE(  19)					_hx_tmp4 = (int)0;
            				}
            				else {
HXLINE(  19)					HX_VARI_NAME( int,z4,"z") = ((int)decodeState->acc & (int)(int)65535);
HXDLIN(  19)					decodeState->acc = hx::UShr(decodeState->acc,(int)16);
HXDLIN(  19)					decodeState->validBits = (decodeState->validBits - (int)16);
HXDLIN(  19)					_hx_tmp4 = z4;
            				}
            			}
            			else {
HXLINE(  19)				HX_VARI_NAME( int,z5,"z") = ((int)decodeState->acc & (int)(int)65535);
HXDLIN(  19)				decodeState->acc = hx::UShr(decodeState->acc,(int)16);
HXDLIN(  19)				decodeState->validBits = (decodeState->validBits - (int)16);
HXDLIN(  19)				_hx_tmp4 = z5;
            			}
            		}
HXDLIN(  19)		m->transformtype = _hx_tmp4;
HXLINE(  20)		int _hx_tmp6;
HXDLIN(  20)		if ((decodeState->validBits < (int)0)) {
HXLINE(  20)			_hx_tmp6 = (int)0;
            		}
            		else {
HXLINE(  20)			if ((decodeState->validBits < (int)8)) {
HXLINE(  20)				if ((decodeState->validBits == (int)0)) {
HXLINE(  20)					decodeState->acc = (int)0;
            				}
HXDLIN(  20)				while(true){
HXLINE(  20)					bool _hx_tmp7;
HXDLIN(  20)					if ((decodeState->bytesInSeg == (int)0)) {
HXLINE(  20)						if (!(decodeState->lastSeg)) {
HXLINE(  20)							_hx_tmp7 = (decodeState->next() == (int)0);
            						}
            						else {
HXLINE(  20)							_hx_tmp7 = true;
            						}
            					}
            					else {
HXLINE(  20)						_hx_tmp7 = false;
            					}
HXDLIN(  20)					if (_hx_tmp7) {
HXLINE(  20)						decodeState->validBits = (int)-1;
HXDLIN(  20)						goto _hx_goto_4;
            					}
            					else {
HXLINE(  20)						decodeState->bytesInSeg--;
HXDLIN(  20)						int a3 = decodeState->acc;
HXDLIN(  20)						decodeState->inputPosition = (decodeState->inputPosition + (int)1);
HXDLIN(  20)						int b3 = decodeState->input->readByte();
HXDLIN(  20)						decodeState->acc = (a3 + ((int)b3 << (int)decodeState->validBits));
HXDLIN(  20)						decodeState->validBits = (decodeState->validBits + (int)8);
            					}
HXDLIN(  20)					if (!((decodeState->validBits < (int)8))) {
HXLINE(  20)						goto _hx_goto_4;
            					}
            				}
            				_hx_goto_4:;
HXDLIN(  20)				if ((decodeState->validBits < (int)0)) {
HXLINE(  20)					_hx_tmp6 = (int)0;
            				}
            				else {
HXLINE(  20)					HX_VARI_NAME( int,z6,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  20)					decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  20)					decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  20)					_hx_tmp6 = z6;
            				}
            			}
            			else {
HXLINE(  20)				HX_VARI_NAME( int,z7,"z") = ((int)decodeState->acc & (int)(int)255);
HXDLIN(  20)				decodeState->acc = hx::UShr(decodeState->acc,(int)8);
HXDLIN(  20)				decodeState->validBits = (decodeState->validBits - (int)8);
HXDLIN(  20)				_hx_tmp6 = z7;
            			}
            		}
HXDLIN(  20)		m->mapping = _hx_tmp6;
HXLINE(  21)		if ((m->windowtype != (int)0)) {
HXLINE(  22)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Mode.hx",1b,97,89,ba),22,HX_("stb.format.vorbis.data.Mode",b6,7b,5b,36),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  24)		if ((m->transformtype != (int)0)) {
HXLINE(  25)			HX_STACK_DO_THROW( ::stb::format::vorbis::data::ReaderError_obj::__alloc( HX_CTX ,::stb::format::vorbis::data::ReaderErrorType_obj::INVALID_SETUP_dyn(),null(),hx::SourceInfo(HX_("Mode.hx",1b,97,89,ba),25,HX_("stb.format.vorbis.data.Mode",b6,7b,5b,36),HX_("read",56,4b,a7,4b))));
            		}
HXLINE(  27)		return m;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Mode_obj,read,return )


Mode_obj::Mode_obj()
{
}

hx::Val Mode_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"mapping") ) { return hx::Val( mapping); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"blockflag") ) { return hx::Val( blockflag); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"windowtype") ) { return hx::Val( windowtype); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"transformtype") ) { return hx::Val( transformtype); }
	}
	return super::__Field(inName,inCallProp);
}

bool Mode_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"read") ) { outValue = read_dyn(); return true; }
	}
	return false;
}

hx::Val Mode_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"mapping") ) { mapping=inValue.Cast< int >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"blockflag") ) { blockflag=inValue.Cast< bool >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"windowtype") ) { windowtype=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"transformtype") ) { transformtype=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Mode_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("blockflag","\x79","\xab","\x73","\x5e"));
	outFields->push(HX_HCSTRING("mapping","\x0e","\x7b","\x7a","\x44"));
	outFields->push(HX_HCSTRING("windowtype","\xaa","\x3e","\x06","\xed"));
	outFields->push(HX_HCSTRING("transformtype","\x26","\x46","\x7d","\x8f"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Mode_obj_sMemberStorageInfo[] = {
	{hx::fsBool,(int)offsetof(Mode_obj,blockflag),HX_HCSTRING("blockflag","\x79","\xab","\x73","\x5e")},
	{hx::fsInt,(int)offsetof(Mode_obj,mapping),HX_HCSTRING("mapping","\x0e","\x7b","\x7a","\x44")},
	{hx::fsInt,(int)offsetof(Mode_obj,windowtype),HX_HCSTRING("windowtype","\xaa","\x3e","\x06","\xed")},
	{hx::fsInt,(int)offsetof(Mode_obj,transformtype),HX_HCSTRING("transformtype","\x26","\x46","\x7d","\x8f")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Mode_obj_sStaticStorageInfo = 0;
#endif

static ::String Mode_obj_sMemberFields[] = {
	HX_HCSTRING("blockflag","\x79","\xab","\x73","\x5e"),
	HX_HCSTRING("mapping","\x0e","\x7b","\x7a","\x44"),
	HX_HCSTRING("windowtype","\xaa","\x3e","\x06","\xed"),
	HX_HCSTRING("transformtype","\x26","\x46","\x7d","\x8f"),
	::String(null()) };

static void Mode_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Mode_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Mode_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Mode_obj::__mClass,"__mClass");
};

#endif

hx::Class Mode_obj::__mClass;

static ::String Mode_obj_sStaticFields[] = {
	HX_HCSTRING("read","\x56","\x4b","\xa7","\x4b"),
	::String(null())
};

void Mode_obj::__register()
{
	hx::Object *dummy = new Mode_obj;
	Mode_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("stb.format.vorbis.data.Mode","\xb6","\x7b","\x5b","\x36");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Mode_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Mode_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Mode_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Mode_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Mode_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Mode_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Mode_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Mode_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace stb
} // end namespace format
} // end namespace vorbis
} // end namespace data
